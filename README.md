# thread_pool
一个简单的Linux环境下C语言的线程池的实现，可用来学习基本线程。<br>
The simple implement of thread poll.<br> 

## 1. 线程池的特点： <br>
* 线程池拥有若干个线程；<br>
    a. 线程数量具有限制，通常小于并发的任务量；<br>
* 它主要用于执行大量的相对短暂的任务；<br>
    a. 计算密集型任务： 线程个数=CPU个数<br>
    b. I/O密集型任务： 线程个数>CPU个数<br>
* 如果任务执行时间很长，那么就不适合放到线程中进行处理；<br>
## 2. 该线程池的实现特点：<br>
* 用于执行大量相对短暂的任务；<br>
* 当任务增加的时候能够动态的增加线程池中线程的数量知道达到一个阈值；<br>
* 当任务执行完毕时， 能够动态销毁线程池中的线程。<br>

`Note`: 本质是生产者-消费者模型<br>
生产者线程向任务队列中添加任务，一旦队列有任务到来，如果有等待线程就唤<br>
醒来执行任务，如果没有等待线程并且线程数没有达到阈值，就会创建新的线程来执行任务。<br>
# thread pool with C++
--------------------
This is simple implement of thread poll with c++;<br>
线程池技术可以使得处理器尽量保持在忙碌的状态，充分利用系统的可用的资源，使得系统的性能<br>
得到显著提高。<br>
线程池技术的优点：<br>
* 可以控制产生线程的数量。通过预先创建一定数量的工作线程并限制其数量，控制线程对象的内存消耗
* 降低系统开销和资源消耗。通过对多个请求重用线程、线程创建、销毁的开销被分摊到多个请求上。通过限制线程数量，降低系统在垃圾回收方面的开销
* 提高系统响应速度。
## basic theory
一般来说实现一个线程池主要包括以下几个部分组成：<br>
* 线程管理器：用于创建并管理线程池。
* 工作线程：线程池中实际执行任务的线程。
* 任务接口：每个任务必须实现的接口，当线程池中的可执行的任务，被工作线程调试执行。把任务抽象出来形成任务接口，可以做到线程池与具体任务无关
* 任务队列：用来存放没有处理的任务，提供一种缓冲机制。<br>
    实现这种结构有好几种方法，最常用的是队列，主要利用队列的先进先出的工作原理。另一种是链表之类的<br>
    数据结构，可以动态为它分配内存，应用中比较灵活。<br>
## funciton and struct
